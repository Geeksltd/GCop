# Error list
GCop code | Description
--- | ---
100 | [Replace with Log.Error(...)](/Rules/GCop100.md)
101 | [Too many parameters as argument. Define a container and encapsulate them](/Rules/GCop101.md)
102 | [Use \{"Address"}.AsDirectory() instead of \{new DirectoryInfo("Address")}](/Rules/GCop102.md)
103 | [Instead of 'null', return an empty collection such as 'Enumerable.Empty<method.ReturnType>'](/Rules/GCop103.md)
104 | [Remove empty partial class](/Rules/GCop104.md)
106 | [Use **FileAddressString.AsFile()** instead of New **FileInfo(FileAddressString)**](/Rules/GCop106.md)
107 | [Do not use \{this.Get()}. 'this' is never null](/Rules/GCop107.md)
108 | [Instead of GetValueOrDefault(defaultValue) method use \" ?? defaultValue\".](/Rules/GCop108.md)
109 | [Use something.HasMany() instead of something.Count() > 1, as it will be faster and more descriptive.](/Rules/GCop109.md)
111 | [Use implicit generic method typing](/Rules/GCop111.md)
112 | [This class is too large. Break its responsibilities down into more classes.](/Rules/GCop112.md)
114 | [DateTime.Now is not TDD friendly. Use LocalTime.Now instead.](/Rules/GCop114.md)
115 | [This IF statement is too long for one line. Break the body of the IF into another line](/Rules/GCop115.md)
116 | [Break this down into smaller methods. If such methods would become meaningless as standalone methods in the context of the class, you can refactor this method into a Stateful Service class](/Rules/GCop116.md)
117 | [The meaning of **true / false** is not obvious. Specify the parameter's name explicitly.](/Rules/GCop117.md)
119 | [Don’t use **ref / out** parameters in method definition. To return several objects, define a class or struct for your method return type.](/Rules/GCop119.md)
120 | [Use someIntVariable.Hours() instead of TimeSpan.FromHours(someIntVariable)](/Rules/GCop120.md)
121 | [Use **numeric string.To< data type >()** instead of **data type.Parse(numeric string)**](/Rules/GCop121.md)
122 | [Use Database.CreateTransactionScope() instead of \{TransactionScope}](/Rules/GCop122.md)
123 | [Transaction is created but the method.Complete() is never called.](/Rules/GCop123.md)
124 | [Use **numeric string.TryParseAs< data type >()** instead of **data type.TryParse(numeric string)**](/Rules/GCop124.md)
126 | [To handle both null and empty string scenarios, use **IsEmpty / HasValue** instead](/Rules/GCop126.md)
127 | [Use \{CollectionName}.IDs() instead of \{ColectionName.select}](/Rules/GCop127.md)
128 | [\{IHierarchy} interface should be set in M# on the entity definition](/Rules/GCop128.md)
129 | [Change to an instance method, instead of taking a parameter  with the same type as the class.](/Rules/GCop129.md)
130 | [Instead of ?? Enumerable.Empty<>() use .OrEmpty() for collections that can be null](/Rules/GCop130.md)
131 | [Use \{collectionName}.ToString(\{seperator}) instead of \{string.Join}(\{seperator}, \{collectionName})](/Rules/GCop131.md)
132 | [Since the type is inferred, use 'var' instead](/Rules/GCop132.md)
134 | [This method should not contain complex code, Instead call other focused methods to perform the complex logic](/Rules/GCop134.md)
135 | [Add a 'default' block after the last case in a switch statement. For example if you don't support anything other than your specified 'cases' throw a NotSupportedException](/Rules/GCop135.md)
136 | [All constants and class fields should be defined at the top of the class, before all methods.](/Rules/GCop136.md)
137 | [Avoid locking on a Type or on the current object instance.](/Rules/GCop137.md)
138 | [When you catch an exception you should throw exception or at least log the error](/Rules/GCop138.md)
140 | [Consider making it "private" as it's not used outside of this class.](/Rules/GCop140.md)
141 | [Avoid using goto command](/Rules/GCop141.md)
142 | [Replace \{!stringObject.HasValue()} with \{stringObject.IsEmpty()}](/Rules/GCop142.md)
143 | [First line of OnSaved() method must be a call to base.OnSaved() otherwise CachedReferences will have a problem.](/Rules/GCop143.md)
144 | [Since there is only one statement, remove the unnecessary braces and write it as `Database.Update( myObject, x => x.Abc = value );`](/Rules/GCop144.md)
145 | [This phrase is translated to SQL which handles NULL implicitly. Do not worry about null values and write your query against the property (path) simply without using .Get(x => x...) or ?.](/Rules/GCop145.md)
146 | [This public method doesn't seem to be used in the solution. Consider removing it.](/Rules/GCop146.md)
147 | [Instead of comparing the Id properties, just compare the objects directly.](/Rules/GCop147.md)
148 | [All constructors should be before all methods in a class.](/Rules/GCop148.md)
149 | [Instead of using string literal as parameter name use nameof(variableName)](/Rules/GCop149.md)
151 | [Equals or == should be used](/Rules/GCop151.md)
153 | [Instead use IEnumerable< T >.Lacks(T item)](/Rules/GCop153.md)
154 | [Should be written simply as \{FirstCollection}.Except(\{SecondCollection})](/Rules/GCop154.md)
155 | [Should be written simply as `{CollectionName}.Intersect({AnotherCollectionName})`](/Rules/GCop155.md)
156 | [Should be written as CookieProperty.Remove(\{key})](/Rules/GCop156.md)
157 | [Use == instead](/Rules/GCop157.md)
159 | [In OnSaved method, the property `IsNew` must not be used, instead use: e.Mode == SaveMode.Insert](/Rules/GCop159.md)
160 | [This is not readable. Either refactor into a method, or use If / else statement.](/Rules/GCop160.md)
161 | [Since the {left / right} side of condition is just Bool, then \" == true\" is unnecessary](/Rules/GCop161.md)
162 | [Replace with **.IsAnyOf()**](/Rules/GCop162.md)
163 | [Subsequent OrderBy or OrderByDescending cancel each other out. Instead ThenBy or ThenByDescending should be called.](/Rules/GCop163.md)
164 | [Instead use Config.GetConnectionString()](/Rules/GCop164.md)
165 | [Instead of .IndexOf(\{intendedChar}) > -1 use .Contains(\{intendedChar}).](/Rules/GCop165.md)
166 | [Avoid assignment within conditional statements](/Rules/GCop166.md)
167 | [OnSaving() is called after Validate() and property values set in OnSaving() won't be validated. Instead use OnValidating() to write your prep logic.](/Rules/GCop167.md)
168 | [Don't instantiate a variable with the **new** keyword if you are going to assign it to a different object immediately.](/Rules/GCop168.md)
169 | [Remove \{NullableObject.HasValue} which is redundant. If \{NullableObject.HasValue} is null, then '\{rightExpression}' will be false anyway.](/Rules/GCop169.md)
171 | [There is no need for calling .Value. Replace with 'Paarmeter without .Value'](/Rules/GCop171.md)
172 | [Remove the check for null. Instead use NullableObject?.Invoke()](/Rules/GCop172.md)
173 | [Don't throw exception inside static constructors.](/Rules/GCop173.md)
174 | [You should use the method `Exists()` instead of the property, because the property caches the result - which can cause problems.](/Rules/GCop174.md)
175 | [This condition is very long. Either refactor that into a method, or define interim variables to 'document' your purpose, and use the variable(s) in the IF clause.](/Rules/GCop175.md)
176 | [This anonymous method should not contain complex code, Instead call other focused methods to perform the complex logic](/Rules/GCop176.md)
177 | [Variable declaration is unnecessary due to it being used only for return statement](/Rules/GCop177.md)
178 | [Use parenthesis to clarify your boolean logic intention.](/Rules/GCop178.md)
179 | [o not hardcode numbers, strings or other values. Use constant fields, enums, config files or database as appropriate](/Rules/GCop179.md)
180 | [Double and float comparison isn't exact in .NET. Use myDouble.AlmostEquals(anotherDouble) instead.](/Rules/GCop180.md)
181 | [Define a virtual method and write this logic using polymorphism.](/Rules/GCop181.md)
200 | [Since the class is an attribute, the name of the class must end with 'Attribute'](/Rules/GCop200.md)
201 | [Use camelCasing when declaring local variables / a parameter.](/Rules/GCop201.md)
202 | [Don’t end the name of **methods** with the same name as the **class**](/Rules/GCop202.md)
203 | [Use meaningful names instead of single character for foreach identifier](/Rules/GCop203.md)
204 | [Rename the variable 'variable name' to something clear and meaningful.](/Rules/GCop204.md)
205 | [Interfaces must start with the letter 'I'."](/Rules/GCop205.md)
206 | [Avoid using underscores in the class name](/Rules/GCop206.md)
207 | [The logic seems extensive. Rename the method to imply this. E.g: Calculate, Find, Select, Create, Evaluate, etc](/Rules/GCop207.md)
209 | [Use PascalCasing for (class or enum or ... ) names.](/Rules/GCop209.md)
210 | [Suffix the name of a service class with 'Service' as it's inside the Services folder.](/Rules/GCop210.md)
214 | [The variable defined to return the result of the method should be named **result**](/Rules/GCop214.md)
215 | [Rename the method to 'Count...' as it's shorter and more readable](/Rules/GCop215.md)
216 | [A method named `GetMethodName` is expected return a value. If it's meant to be void, then use a verb other than `Get` such as Read, Download, Sync, ...](/Rules/GCop216.md)
217 | [Rename the method to Is...Valid](/Rules/GCop217.md)
218 | [For consistency and clarity, use '@this' instead of {'argumentName'} for the first paramter of extension methods](/Rules/GCop218.md)
300 | [Replace with None()](/Rules/GCop300.md)
301 | [Do not throw exceptions using default constructor or with empty message](/Rules/GCop301.md)
302 | [Since 'Idisposable object' implements IDisposable, wrap it in a **using()** statement](/Rules/GCop302.md)
304 | [Property named \{ParameterName}Id should be used instead](/Rules/GCop304.md)
305 | [Error messageReplace with `Database.Find<{T}>({LambdaExpression})`](/Rules/GCop305.md)
306 | [Instead use \{`<` Or `>` Or `<=` Or `>=` Or `> and <` } so it can be converted into a SQL statement and run faster](/Rules/GCop306.md)
309 | [It should be written as \{lambdaExpression}, Because the criteria will be faster and eliminate unnecessary database fetches](/Rules/GCop309.md)
311 | [Throw exception without specifying the original exception. Remove 'exceptionIdentifier' from throw statement.](/Rules/GCop311.md)
313 | [Where should be called first, so it is not doing unnecessary ordering of objects that will be thrown away.](/Rules/GCop313.md)
314 | [You don't need the Where clause. Replace with FirstOrDefault(LambdaExpression)](/Rules/GCop314.md)
315 | [It should be written instead as: `Database.Count<{T}>{(LambdaExpression)}`](/Rules/GCop315.md)
317 | [This code is repeated 'repeatation count' times in this method. If its value remains the same during the method execution, store it in a variable. Otherwise define a method (or Func<T> variable) instead of repeating the expression. 'expression type'](/Rules/GCop317.md)
318 | [This will cause the query to be computed multiple times. Instead call .ToList() on the variable declaration line to avoid unwanted extra processing.](/Rules/GCop318.md)
319 | [[Database.Save(this);] without condition will create a loop in \{OnSaved / OnSaving} method.](/Rules/GCop319.md)
320 | [While \{IEnumerable\<T>} is being enumerated at run-time, saving of each of its items can potentially affect the source expression from which this IEnumerable object is define upon. To avoid unintended side effects, evaluate myobjects into an Array or List before passing it to Database.XXX.](/Rules/GCop320.md)
321 | [The variable \{VariableName} is enumerated multiple times. To improve performance, call `.ToList()` where it's defined.](/Rules/GCop321.md)
400 | [Remove empty object initializer.](/Rules/GCop400.md)
401 | [Instead of setting the properties in separate lines, use constructor initializers.](/Rules/GCop401.md)
402 | [Remove unnecessary parenthesis.](/Rules/GCop402.md)
403 | [Change \{PropertyName} to an auto property](/Rules/GCop403.md)
404 | [Multiple 'if' and 'else if' on the same variable can be replaced with a 'switch'](/Rules/GCop404.md)
405 | [You should use {'conditional access'}](/Rules/GCop405.md)
408 | [Flag or switch parameters (bool) should go after all non-optional parameters. If the boolean parameter is not a flag or switch, split the method into two different methods, each doing one thing.](/Rules/GCop408.md)
410 | [This method seems unnecessary as it only calls the base virtual method.](/Rules/GCop410.md)
412 | [Don't hardcode a path. Consider using “AppDomain.CurrentDomain.GetPath()" instead.](/Rules/GCop412.md)
413 | [It should be written as 'positive expression'](/Rules/GCop413.md)
414 | [Remove .ToString() as it's unnecessary.](/Rules/GCop414.md)
415 | [The same code is repeated in multiple IF branches. Instead update the IF condition to cover both scenarios.](/Rules/GCop415.md)
418 | [Remove the unnecessary casting.](/Rules/GCop418.md)
419 | [This statement is too long and hard to read. Press Enter at logical breaking points to split it into multiple lines.](/Rules/GCop419.md)
420 | [Methods should not be empty.](/Rules/GCop420.md)
421 | [The conditions seems redundant. Either remove the ternary operator, or fix the values.](/Rules/GCop421.md)
423 | [This condition was just checked on line \{lineNumber}.](/Rules/GCop423.md)
424 | [This method is redundant. Callers of this method can just call \{Collection Name}.Count() which is as clean.](/Rules/GCop424.md)
429 | [Change to `{LambdaIdentifier.Id} == {EntityObject}` as you can compare Guid with Entity directly. It handles null too.](/Rules/GCop429.md)
430 | [Use \" NotEqualsExpression.HasValue \" as negative logic is taxing on the brain.](/Rules/GCop430.md)
431 | [Use \" \{expression } is \{type} \" as negative logic is taxing on the brain.](/Rules/GCop431.md)
432 | [Unnecessary paranthesis should be removed.](/Rules/GCop432.md)
433 | [Class name is unnecessary here. Static members can be called directly.](/Rules/GCop433.md)
434 | [Class name is unnecessary here. Static members can be called directly.](/Rules/GCop434.md)
435 | [Finally block should not be empty](/Rules/GCop435.md)
437 | [Complete the task associated to this \"TODO\" comment.](/Rules/GCop437.md)
439 | [Only one partial file for a class should specify the class modifiers (public, static, ...)](/Rules/GCop439.md)
500 | [Void async methods cannot be awaited. Also they can hide exceptions and cause tricky bugs. Return a Task instead.](/Rules/GCop500.md)
501 | [Do not call {'MethodName'} method of class {'ClassName'} as a static method](/Rules/GCop501.md)
502 | [The parameter '{ParameterName}' doesn't seem to be used in this method. Consider removing it. If the argument must be declared for compiling reasons, rename it to contain only underscore character.](/Rules/GCop502.md)
504 | [The number of arguments in  `{Format / FormatWith}` is incorrect.](/Rules/GCop504.md)
507 | [Remember to implement this method.](/Rules/GCop507.md)
508 | [Since the condition is already a boolean it can be returned directly.](/Rules/GCop508.md)
511 | [Either remove the parameter documentation node, or describe it properly.](/Rules/GCop511.md)
512 | [Use \"NullableObject.Value\" instead.](/Rules/GCop512.md)
513 | [It should be written as \{Collection}.FirstOfDefault(\{argument}) ?? \{conditionWhenFalse}.](/Rules/GCop513.md)
516 | [Mark \{PropertyName} as Unique in M# and use the autogenerated `FindBy{PropertyName}` method instead.](/Rules/GCop516.md)
517 | [{'MethodName()'} returns a value but doesn't change the object. It's meaningless to call it without using the returned result.](/Rules/GCop517.md)
519 | [Use `MaxOrNull(LambdaExpression)` instead.](/Rules/GCop519.md)
521 | [Change it to {'NotRoundedObject'}.Round(digits).](/Rules/GCop521.md)
523 | [Database search is case insensitive. Simply use `{LambdaIdentifier}.{Property} == yourValue` for a faster execution.](/Rules/GCop523.md)
524 | [Remove private keyword.](/Rules/GCop524.md)
526 | [Use the Generic version instead. Ensure you have `using System.Reflection;`](/Rules/GCop526.md)
528 | [Use IsA() or IsA\<T>() instead.](/Rules/GCop528.md)
529 | [Use 'IEnumerable< MyClassObject >' instead.](/Rules/GCop529.md)
530 | [Write this as \{variableName}.WithSuffix(\{SuffixString}).](/Rules/GCop530.md)
531 | [Write this as \{variableName}.WithPrefix(\{PrefixString}).](/Rules/GCop531.md)
533 | [Choose return type of `IEnumerable<\{entityType}>` to imply that it's not modifiable.](/Rules/GCop533.md)
534 | [Use yourMemberInfo.Defines< TYPE > instead.](/Rules/GCop534.md)
535 | [Use ToLocal() method instead, so you get control over it using via LocalTime.CurrentTimeZone.](/Rules/GCop535.md)
536 | [Remove empty xml node documentation](/Rules/GCop536.md)
538 | [File extensions can have different casing. Use case insensitive string comparison.](/Rules/GCop538.md)
539 | [Don't hard-code URLs in the code as they might be subject to change. Use Config.Get(...) instead.](/Rules/GCop539.md)
540 | [Abastract class should not have public constructors. Make it protected instead.](/Rules/GCop540.md)
541 | [Simply the method by removing the `async` and `await` keywords and just return the task directly.](/Rules/GCop541.md)
543 | [The Result property of the Task object should never be called. Either properly await it, or call GetAlreadyCompletedResult().](/Rules/GCop543.md)
544 | [It should be written as : `SomeParameter = -SomeParameter`](/Rules/GCop544.md)
605 | [Use \{parameterName}.To<\{toType}>() instead.](/Rules/GCop605.md)
606 | [For string value existence checking use the more readable methods of .HasValue() or .IsEmpty()](/Rules/GCop606.md)
607 | [It should be written as Enumerable.Except< TSource >](/Rules/GCop607.md)
608 | [A secure file should be made available only to authorised users, not just any user. Apply proper checks.](/Rules/GCop608.md)
611 | [It should be written as `Database.Reload({ParameterName})`.](/Rules/GCop611.md)
613 | [It should be written as `Database.Get<{T}>({Guid})`.](/Rules/GCop613.md)
614 | [Random instance should be defined and instantiated as a static class field.](/Rules/GCop614.md)
615 | [Negative logical comparisons are taxing on the brain. Instead of "!object.Any()" use "object.None()".](/Rules/GCop615.md)
616 | [Reverse your IF criteria and use 'continue'. That will eliminate the need for a big IF block and make the code more readable.](/Rules/GCop616.md)
617 | [Avoid deep nesting of IF statements. Break the method down into smaller methods, or return early if possible.](/Rules/GCop617.md)
618 | [Use `{EntityName.FindByPropertyName("SomeValue")}` instead.](/Rules/GCop618.md)
619 | [Should be written "{'conditionText'}".](/Rules/GCop619.md)
620 | [To simplify the condition use the "??".](/Rules/GCop620.md)
621 | [Drop "Where" and move the condition into the "FirstOrDefault".](/Rules/GCop621.md)
622 | [Reverse your IF condition and return. Then move the nested statements to after the IF.](/Rules/GCop622.md)
624 | [Write it as  \{CollectionName}.\{Contains}(VALUE)](/Rules/GCop624.md)
625 | [Using `!=` operator on the entity is not converted into SQL. Use x.ID != [...].ID instead.](/Rules/GCop625.md)
626 | [The condition is unnecessary.](/Rules/GCop626.md)
627 | [Instead of « ?? false » use the more readable expression of « == true »](/Rules/GCop627.md)
629 | [\{EntityName} already has a property named \{PropertyName}, Use that instead of ID](/Rules/GCop629.md)
630 | [Override the Validate() method and write your validation logic there.](/Rules/GCop630.md)
631 | [All validation logic should be written inside Validate() method. OnValidating is meant to be used for special cases such as setting late-bound default values.](/Rules/GCop631.md)
632 | [Use OnValidating() for setting late-bound properties. Validate() should only be used for validation, without changing the object state.](/Rules/GCop632.md)
633 | [Instead of hard-coding the boundary check, set the boundary of the NumericProperty in its M# definition.](/Rules/GCop633.md)
634 | [Instead of private property, use a class field.](/Rules/GCop634.md)
635 | [The condition of the where clause is very long and should be turned into a method.](/Rules/GCop635.md)
636 | [It should be written as if ( {'NullableObject'}?.{'YourProperty'} == someValue)](/Rules/GCop636.md)
637 | [This will be invoked twice: once for a clone of the object, and once for the actual objec](/Rules/GCop637.md)
638 | [Shorten this method by defining it as expression-bodied.](/Rules/GCop638.md)
639 | [It should be written as if ({'yourObject'}?.{'Property'} != null)](/Rules/GCop639.md)
640 | [Write it as \{CollectionName}.Contains(VALUE)](/Rules/GCop640.md)
641 | [Use the OrEmpty() method instead.](/Rules/GCop641.md)
642 | [Replace with \{whenTrueReturnType}.Or(\{whenFalseReturnType})](/Rules/GCop642.md)
643 | [Change to return {something} ?? {somethingElse};](/Rules/GCop643.md)
646 | [Email addresses should not be hard-coded. Move this to Settings table or Config file.](/Rules/GCop646.md)
647 | [Shorten this property by defining it as expression-bodied.](/Rules/GCop647.md)
648 | [Use stringPhrase.Remove(oldValue) instead](/Rules/GCop648.md)
650 | [If this is an Api controller, instead of [Authorize] use [AuthorizeApi] attribute.](/Rules/GCop650.md)
651 | [Wait() method can cause a deadlock. Use the await keyword on the method call instead.](/Rules/GCop651.md)
652 | [if (\{myVariable}.Any()) is unnecessary when using foreach.](/Rules/GCop652.md)
653 | [Use the await keyword on the method call instead of AsyncMethod().Result; Also it can be used AsyncMethod().GetAwaiter().GetResult(); for better exception handling.](/Rules/GCop653.md)
654 | [Awaiting null will throw a runtime error. Add '?? Task.CompletedTask' after the expression.](/Rules/GCop654.md)
655 | [Change this method to return a Task](/Rules/GCop655.md)
690 | [Negative logic is taxing on the brain. Use variable == null instead.](/Rules/GCop690.md)
691 | [Non-public methods should not need basic argument validation.](/Rules/GCop691.md)
