namespace GCop.MSharp.Rules.Usage
{
    using Core;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Diagnostics;
    using System.Linq;

    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public class FindByPropertyAnalyzer : GCopAnalyzer<SyntaxNodeAnalysisContext, SyntaxKind>
    {
        protected override SyntaxKind Kind => SyntaxKind.InvocationExpression;

        protected override RuleDescription GetDescription()
        {
            return new RuleDescription
            {
                ID = "516",
                Category = Category.Usage,
                Severity = DiagnosticSeverity.Warning,
                Message = "Mark {0} as Unique in M# and use the autogenerated FindBy{0} method instead."
            };
        }

        protected override void Analyze(SyntaxNodeAnalysisContext context)
        {
            NodeToAnalyze = context.Node;

            var invocation = context.Node as InvocationExpressionSyntax;

            var memberAccessExpression = invocation.Expression as MemberAccessExpressionSyntax;
            if (memberAccessExpression == null || invocation.ArgumentList.Arguments.None() || invocation.ArgumentList.Arguments.HasMany()) return;

            var methodInfo = context.SemanticModel.GetSymbolInfo(memberAccessExpression).Symbol as IMethodSymbol;
            if (methodInfo == null || methodInfo.Name != "Find" || methodInfo.ContainingType.Name != "Database" || methodInfo.ContainingAssembly.Name != "MSharp.Framework") return;

            var lambdaExpression = invocation.ArgumentList.Arguments.FirstOrDefault()?.Expression as SimpleLambdaExpressionSyntax;
            if (lambdaExpression == null) return;
            var equalsExpression = lambdaExpression.ChildNodes().FirstOrDefault(it => it?.Kind() == SyntaxKind.EqualsExpression) as BinaryExpressionSyntax;
            if (equalsExpression == null) return;

            if (equalsExpression.Left?.As<MemberAccessExpressionSyntax>()?.ChildNodes().OfType<MemberAccessExpressionSyntax>().Any() ?? true) return;

            var propertyIdentifier = equalsExpression?.Left.As<MemberAccessExpressionSyntax>()?.ChildNodes().OfType<IdentifierNameSyntax>().LastOrDefault();
            if (propertyIdentifier == null || propertyIdentifier.Identifier.ValueText == lambdaExpression.Parameter.Identifier.ValueText) return;

            var property = context.SemanticModel.GetSymbolInfo(propertyIdentifier).Symbol as IPropertySymbol;
            //If the property is ID it will be handled by another rule.
            if (property == null || property.Name == "ID") return;

            var memberName = $"FindBy{property.Name}";
            var containingMethod = context.Node.Ancestors().OfType<MethodDeclarationSyntax>().FirstOrDefault();
            if (containingMethod.GetName() == memberName) return;
            if (property.ContainingType.GetMembers().None(member => member.Name == memberName && member.Kind == SymbolKind.Method && member.IsStatic))
            {
                ReportDiagnostic(context, invocation, property.Name);
            }
        }
    }
}
